<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>conferenceBuddy — Session Recorder</title>
  <style>
    :root{
      --bg:#0b1530;        /* dark blue background */
      --bg2:#0d1a3f;
      --card:#121f48;
      --text:#ffffff;
      --muted:#9fb4ff;
      --accent:#3b82f6;
      --accent-2:#2563eb;
      --danger:#ef4444;
      --ok:#22c55e;
      --border:rgba(255,255,255,0.14);
    }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    button,input,select,textarea{font:inherit;color:inherit}
    a{color:var(--muted)}
    .bar{position:sticky;top:0;z-index:50;background:linear-gradient(180deg,var(--bg2),var(--bg));border-bottom:1px solid var(--border)}
    .wrap{max-width:960px;margin:0 auto;padding:12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .row>*{flex:0 0 auto}
    .input{background:var(--card);border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:10px}
    .input.wide{min-width:220px}
    .btn{background:var(--accent);border:1px solid #1d4ed8;padding:10px 14px;border-radius:12px;color:#fff;cursor:pointer}
    .btn.secondary{background:#0f172a;border-color:var(--border)}
    .btn.ghost{background:transparent;border:1px solid var(--border)}
    .btn.danger{background:var(--danger);border-color:#b91c1c}
    .btn.ok{background:var(--ok);border-color:#16a34a}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .grid{display:grid;gap:12px}
    @media (min-width:700px){.grid.two{grid-template-columns:1fr 1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:12px}
    .title{font-weight:600;margin:0 0 6px 0}
    .muted{color:var(--muted);font-size:12px}
    .pill{padding:3px 8px;border-radius:999px;background:#0f1f56;border:1px solid var(--border);font-size:12px}
    .toolbar{display:flex;gap:6px;flex-wrap:wrap}
    .stack{display:flex;flex-direction:column;gap:8px}
    .thumbs{display:flex;gap:8px;overflow:auto;padding-bottom:4px}
    .thumbs img{height:72px;border-radius:10px;border:1px solid var(--border)}
    .list{display:flex;flex-direction:column;gap:8px;max-height:360px;overflow:auto}
    .logbox{white-space:pre-wrap;background:#081028;border:1px solid var(--border);padding:10px;border-radius:10px;min-height:120px;max-height:260px;overflow:auto;color:#dbeafe}
    .small{font-size:12px}
  </style>
</head>
<body>
  <!-- Top bar -->
  <div class="bar">
    <div class="wrap row">
      <strong>conferenceBuddy — Sessions</strong>
      <span class="pill" id="statusPill">idle</span>
      <span class="muted small" id="hint"></span>
      <div style="flex:1"></div>
      <button class="btn ghost" id="btnApi">API</button>
      <button class="btn ghost" id="btnLogs">Logs</button>
      <button class="btn ghost" id="btnSelfTest">Self-Test</button>
    </div>
  </div>

  <div class="wrap grid two" id="app">
    <!-- Recorder / Uploader -->
    <section class="card stack" id="recCard">
      <h3 class="title">New Session</h3>
      <div class="toolbar">
        <input id="apiBase" class="input wide" placeholder="API Base (e.g. https://…/api)" />
        <input id="apiKey" class="input wide" placeholder="API Key" />
        <button class="btn" id="btnSaveCfg">Save</button>
      </div>

      <div class="toolbar">
        <select id="conferenceSel" class="input wide"></select>
        <select id="vendorSel" class="input wide"></select>
        <button class="btn secondary" id="btnRefresh">Refresh Lists</button>
      </div>

      <div class="toolbar">
        <button class="btn ok" id="btnStart">Start</button>
        <button class="btn danger" id="btnStop" disabled>Stop</button>
        <span class="muted" id="timer">00:00</span>
      </div>

      <div class="stack">
        <label class="muted">Notes</label>
        <textarea id="notes" class="input" rows="6" placeholder="Your notes…"></textarea>
      </div>

      <div class="stack">
        <label class="muted">Add Photos</label>
        <input id="photoPicker" class="input" type="file" accept="image/*" multiple />
        <div class="thumbs" id="thumbs"></div>
      </div>

      <div class="toolbar">
        <button class="btn" id="btnUpload" disabled>Upload Session</button>
        <button class="btn ghost" id="btnClear">Clear</button>
      </div>

      <div class="stack small">
        <div>Recorder: <span id="recInfo">n/a</span></div>
        <div>Audio size: <span id="audSize">0.00 MB</span></div>
      </div>
    </section>

    <!-- Previous sessions -->
    <section class="card stack">
      <h3 class="title">Previous Sessions</h3>
      <button class="btn secondary" id="btnLoadSessions">Load Sessions</button>
      <div class="list" id="sessionList"></div>
    </section>

    <!-- Diagnostics -->
    <section class="card stack" style="grid-column:1/-1;">
      <h3 class="title">Diagnostics & Logs</h3>
      <div class="toolbar">
        <label class="muted"><input type="checkbox" id="verbose" /> Verbose</label>
        <button class="btn ghost" id="btnCopy">Copy</button>
        <button class="btn ghost" id="btnDownloadTxt">.txt</button>
        <button class="btn ghost" id="btnDownloadJson">.json</button>
        <span class="muted small" id="logStats"></span>
      </div>
      <div id="logs" class="logbox" aria-live="polite"></div>
    </section>
  </div>

<script>
(() => {
  // ------------------ Logger ------------------
  const logsEl = document.getElementById('logs');
  const logStats = document.getElementById('logStats');
  const verboseChk = document.getElementById('verbose');
  const logBuf = [];
  const log = (level, msg, extra = '') => {
    const entry = { t: new Date().toISOString(), level, msg, extra };
    logBuf.push(entry);
    const short = !verboseChk.checked;
    const line = short ? `${entry.t} [${level.toUpperCase()}] ${msg}` :
      JSON.stringify(entry, null, 2);
    const needNL = logsEl.textContent && !logsEl.textContent.endsWith("\n");
    logsEl.textContent += (needNL ? "\n" : "") + line + "\n";
    logsEl.scrollTop = logsEl.scrollHeight;
    logStats.textContent = `${logBuf.length} entries`;
    return entry;
  };
  const logHttpReq = (id, method, url, headers) =>
    log('info', `HTTP ${method} ${url}`, `→ request`) &&
    log('info', JSON.stringify({id, method, url, reqHeaders: headers || {} }));
  const logHttpRes = (id, url, dur, status, resHeaders, body) => {
    log('info', `HTTP ${url}`, `← ${status}  (${dur}ms)`);
    log('info', JSON.stringify({id, dur: String(dur), status, resHeaders, body: (body || '') + "\n"}));
  };

  // ------------------ State ------------------
  const els = {
    apiBase: document.getElementById('apiBase'),
    apiKey: document.getElementById('apiKey'),
    btnSaveCfg: document.getElementById('btnSaveCfg'),
    btnRefresh: document.getElementById('btnRefresh'),
    conferenceSel: document.getElementById('conferenceSel'),
    vendorSel: document.getElementById('vendorSel'),
    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    timer: document.getElementById('timer'),
    recInfo: document.getElementById('recInfo'),
    audSize: document.getElementById('audSize'),
    notes: document.getElementById('notes'),
    photoPicker: document.getElementById('photoPicker'),
    thumbs: document.getElementById('thumbs'),
    btnUpload: document.getElementById('btnUpload'),
    btnClear: document.getElementById('btnClear'),
    btnLoadSessions: document.getElementById('btnLoadSessions'),
    sessionList: document.getElementById('sessionList'),
    statusPill: document.getElementById('statusPill'),
    hint: document.getElementById('hint'),
    btnApi: document.getElementById('btnApi'),
    btnLogs: document.getElementById('btnLogs'),
    btnSelfTest: document.getElementById('btnSelfTest'),
    btnCopy: document.getElementById('btnCopy'),
    btnDownloadTxt: document.getElementById('btnDownloadTxt'),
    btnDownloadJson: document.getElementById('btnDownloadJson'),
  };

  let mediaRecorder = null;
  let recordedChunks = [];
  let recStart = 0;
  let timerId = null;
  let chosenMime = null;
  let photos = [];
  let lastAudioBlob = null;

  // ------------------ Helpers ------------------
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const fmtBytes = b => (b/1048576).toFixed(2) + " MB";
  const setStatus = (txt, kind='pill') => els.statusPill.textContent = txt;

  const saveCfg = () => {
    localStorage.setItem('cb.apiBase', els.apiBase.value.trim());
    localStorage.setItem('cb.apiKey', els.apiKey.value.trim());
    log('info','Config updated.');
  };
  const loadCfg = () => {
    els.apiBase.value = localStorage.getItem('cb.apiBase') || '';
    els.apiKey.value = localStorage.getItem('cb.apiKey') || '';
  };

  function apiUrl(path){
    const base = els.apiBase.value.trim().replace(/\/+$/,'');
    if(!base) throw new Error('API base URL not configured.');
    return path.startsWith('/') ? base + path : base + '/' + path;
  }
  async function apiFetch(path, {method='GET',headers={},body=null,raw=false}={}){
    const url = apiUrl(path);
    const id = Math.random().toString(36).slice(2);
    const hdrs = new Headers(headers);
    if(!hdrs.has('Accept')) hdrs.set('Accept','application/json');
    if(els.apiKey.value.trim()) hdrs.set('X-API-Key', els.apiKey.value.trim());
    logHttpReq(id, method, url, Object.fromEntries(hdrs.entries()));
    const t0 = performance.now();
    let res, text;
    try{
      res = await fetch(url, {method, headers:hdrs, body});
      text = raw ? '' : await res.text();
    }catch(e){
      log('error',`Could not fetch ${url}: ${e.message}`);
      throw e;
    }
    const dur = Math.round(performance.now()-t0);
    const ct = res.headers.get('content-type') || '';
    const bodyOut = raw ? '[binary]' : text;
    logHttpRes(id, `POST ${url}`, dur, res.status, Object.fromEntries(res.headers.entries()), bodyOut);
    if(!res.ok){
      const msg = `HTTP ${res.status} — ${bodyOut || res.statusText}`;
      log('error', msg);
      throw new Error(msg);
    }
    if(raw) return res;
    if(ct.includes('application/json')){
      try { return JSON.parse(text); } catch{ return text; }
    }
    return text;
  }

  // Pick best supported mime for MediaRecorder
  function pickAudioMime(){
    const prefer = [
      'audio/ogg;codecs=opus', // accepted by backend (ogg)
      'audio/ogg',
      'audio/webm;codecs=opus',
      'audio/webm'
    ];
    for(const m of prefer){
      if(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)){
        return m;
      }
    }
    return ''; // let browser decide (likely webm)
  }

  // Transcode a Blob (webm/ogg) to WAV (PCM16)
  async function transcodeToWav(blob){
    const arr = await blob.arrayBuffer();
    const ctx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100 * 30, 44100); // buffer up to ~30s
    // decode
    let audioBuf;
    try{
      audioBuf = await ctx.decodeAudioData(arr.slice(0));
    }catch(e){
      log('error', 'decodeAudioData failed: '+e.message);
      throw e;
    }
    // interleave mono
    const ch = audioBuf.numberOfChannels > 0 ? audioBuf.getChannelData(0) : new Float32Array();
    // encode PCM16 WAV
    const wav = pcm16Wav(ch, audioBuf.sampleRate);
    return new Blob([wav], {type:'audio/wav'});
  }
  function pcm16Wav(float32, sampleRate){
    const numFrames = float32.length;
    const bytesPerSample = 2;
    const blockAlign = 1 * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = numFrames * bytesPerSample;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    let offset = 0;
    const writeStr = s => { for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); };
    writeStr('RIFF');
    view.setUint32(offset, 36 + dataSize, true); offset+=4;
    writeStr('WAVE');
    writeStr('fmt ');
    view.setUint32(offset, 16, true); offset+=4; // PCM subchunk size
    view.setUint16(offset, 1, true); offset+=2; // PCM
    view.setUint16(offset, 1, true); offset+=2; // mono
    view.setUint32(offset, sampleRate, true); offset+=4;
    view.setUint32(offset, byteRate, true); offset+=4;
    view.setUint16(offset, blockAlign, true); offset+=2;
    view.setUint16(offset, 16, true); offset+=2; // bits
    writeStr('data');
    view.setUint32(offset, dataSize, true); offset+=4;
    // samples
    for(let i=0;i<numFrames;i++){
      let s = Math.max(-1, Math.min(1, float32[i]));
      view.setInt16(offset, s<0 ? s*0x8000 : s*0x7fff, true);
      offset+=2;
    }
    return buffer;
  }

  function resetUIAfterUpload(){
    els.notes.value = '';
    photos = [];
    els.thumbs.innerHTML = '';
    lastAudioBlob = null;
    els.audSize.textContent = '0.00 MB';
    setStatus('uploaded');
  }

  // ------------------ UI Wiring ------------------
  els.btnCopy.onclick = () => {
    navigator.clipboard.writeText(logsEl.textContent || '');
    log('info','Logs copied to clipboard.');
  };
  els.btnDownloadTxt.onclick = () => {
    const blob = new Blob([logsEl.textContent || ''], {type:'text/plain'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cb-logs.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  };
  els.btnDownloadJson.onclick = () => {
    const blob = new Blob([JSON.stringify(logBuf,null,2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cb-logs.json';
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // Toggle panels shortcuts
  els.btnApi.onclick = () => { window.scrollTo({top:0,behavior:'smooth'}); };
  els.btnLogs.onclick = () => { document.getElementById('logs').scrollIntoView({behavior:'smooth',block:'center'}); };
  els.btnSelfTest.onclick = async () => {
    try{
      await refreshLists();
      await sleep(100);
      await apiFetch('/health');
      log('info','Self-test OK.');
    }catch(e){ log('error','Self-test failed: ' + e.message); }
  };

  els.btnSaveCfg.onclick = async () => {
    saveCfg();
    try{
      await refreshLists();
    }catch(e){
      log('error','Could not load initial data: ' + e.message);
    }
  };
  els.btnRefresh.onclick = () => refreshLists().catch(e=>log('error',e.message));

  // Photo picker previews
  els.photoPicker.addEventListener('change', (e)=>{
    photos = Array.from(e.target.files || []);
    els.thumbs.innerHTML = '';
    photos.forEach(f=>{
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = ()=> URL.revokeObjectURL(url);
      img.src = url;
      els.thumbs.appendChild(img);
    });
  });

  // Recording controls
  els.btnStart.onclick = async () => {
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      chosenMime = pickAudioMime();
      const opts = chosenMime ? {mimeType: chosenMime} : {};
      mediaRecorder = new MediaRecorder(stream, opts);
      recordedChunks = [];
      mediaRecorder.ondataavailable = e => { if(e.data && e.data.size>0) recordedChunks.push(e.data); };
      mediaRecorder.onstart = ()=> {
        setStatus('recording');
        log('info','Audio recording started.');
        recStart = Date.now();
        ElsEnable(false,true);
        tickTimer();
      };
      mediaRecorder.onstop = ()=> {
        clearInterval(timerId);
        const blob = new Blob(recordedChunks, { type: chosenMime || 'audio/webm' });
        lastAudioBlob = blob;
        els.audSize.textContent = fmtBytes(blob.size);
        log('info', `Audio captured: ${fmtBytes(blob.size)}`);
        ElsEnable(true,false,true);
        setStatus('ready');
      };
      mediaRecorder.start(250);
      mediaRecorder.stream.getAudioTracks()[0].enabled = true;
      els.recInfo.textContent = chosenMime || '(browser default)';
    }catch(e){
      log('error','Mic error: '+e.message);
      alert('Microphone permission/recording failed.');
    }
  };
  els.btnStop.onclick = () => {
    if(mediaRecorder && mediaRecorder.state !== 'inactive'){
      log('info','Stopping recorder…');
      mediaRecorder.stop();
      mediaRecorder.stream.getTracks().forEach(t=>t.stop());
    }
  };

  function tickTimer(){
    timerId = setInterval(()=>{
      const s = Math.floor((Date.now()-recStart)/1000);
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      els.timer.textContent = `${mm}:${ss}`;
    }, 200);
  }

  function ElsEnable(upload=false, stop=false, post=false){
    els.btnStart.disabled = stop;
    els.btnStop.disabled = !stop;
    els.btnUpload.disabled = !upload;
  }

  els.btnClear.onclick = ()=>{
    recordedChunks = [];
    lastAudioBlob = null;
    photos = [];
    els.thumbs.innerHTML='';
    els.notes.value='';
    els.audSize.textContent='0.00 MB';
    setStatus('idle');
  };

  // Load dropdown lists
  async function refreshLists(){
    const base = els.apiBase.value.trim();
    if(!base){ log('error','Could not load initial data: API base URL not configured.'); throw new Error('API base URL not configured.'); }
    // Conferences
    const conf = await apiFetch('/conferences');
    const conferences = (conf && conf.data) || [];
    els.conferenceSel.innerHTML = '';
    addOpt(els.conferenceSel,'','— Select conference (or leave blank) —');
    conferences.forEach(c=> addOpt(els.conferenceSel, c.id, c.name));
    // Vendors (global as a fallback)
    let vendors = [];
    try{
      const vend = await apiFetch('/vendors');
      vendors = (vend && vend.data) || [];
    }catch{ vendors = []; }
    els.vendorSel.innerHTML='';
    addOpt(els.vendorSel,'','— Select vendor (or leave blank) —');
    vendors.forEach(v=> addOpt(els.vendorSel, v.id, v.name));
    log('info','Dropdowns populated from API.');
  }
  function addOpt(sel, val, label){ const o=document.createElement('option');o.value=val;o.textContent=label;sel.appendChild(o); }

  // Unknown fallbacks
  async function ensureUnknowns(){
    let confId = els.conferenceSel.value;
    let vendId = els.vendorSel.value;
    if(!confId){
      // Create "Unknown Conference" once per day
      const today = new Date().toISOString().slice(0,10);
      try{
        const body = JSON.stringify({name:'Unknown Conference', start_date: today, end_date: today});
        const res = await apiFetch('/conferences', {method:'POST', headers:{'Content-Type':'application/json'}, body});
        confId = res.id || (res.data && res.data.id) || (res && res.conference_id) || confId;
      }catch(e){ /* maybe exists */ 
        // search existing
        const list = await apiFetch('/conferences');
        const hit = (list.data||[]).find(c=>c.name==='Unknown Conference');
        confId = hit ? hit.id : confId;
      }
    }
    if(!vendId){
      try{
        const res = await apiFetch('/vendors', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'Unknown Vendor', conference_id: confId || null})});
        vendId = res.id || (res.data && res.data.id) || vendId;
      }catch(e){
        // search
        const all = await apiFetch('/vendors');
        const hit = (all.data||[]).find(v=>v.name==='Unknown Vendor' && (!confId || v.conference_id===confId));
        vendId = hit ? hit.id : vendId;
      }
    }
    return {confId, vendId};
  }

  // Upload flow (single-step preferred per KB; handles audio type fix)
  els.btnUpload.onclick = async () => {
    try{
      const { confId, vendId } = await ensureUnknowns();
      if(!confId || !vendId){ throw new Error('Could not ensure conference/vendor.'); }

      // Ensure acceptable audio type
      let audioBlob = lastAudioBlob;
      let audioName = 'session_audio';
      let okTypes = ['audio/ogg','audio/wav','audio/mp3','audio/mpeg','audio/aac','audio/mp4','audio/x-m4a'];
      if(audioBlob){
        if(audioBlob.type.startsWith('audio/ogg')){
          audioName += '.ogg';
        }else if(audioBlob.type.startsWith('audio/wav')){
          audioName += '.wav';
        }else if(audioBlob.type === 'audio/mpeg' || audioBlob.type === 'audio/mp3'){
          audioName += '.mp3';
        }else{
          // transcode webm → wav
          log('warn','Browser produced '+audioBlob.type+'; transcoding to WAV for compatibility…');
          try{
            audioBlob = await transcodeToWav(audioBlob);
            audioName += '.wav';
          }catch(e){
            log('error','Transcode failed: '+e.message);
            // Continue without audio
            audioBlob = null;
          }
        }
      }

      const startISO = new Date(recStart || Date.now()).toISOString();
      const fd = new FormData();
      fd.append('vendor_id', vendId);
      fd.append('conference_id', confId);
      fd.append('start_time', startISO);
      if(els.notes.value.trim()) fd.append('user_notes', els.notes.value.trim());
      photos.forEach(f => fd.append('photos', f, f.name));
      if(audioBlob) fd.append('audio_file', audioBlob, audioName);

      const id = Math.random().toString(36).slice(2);
      logHttpReq(id, 'POST', apiUrl('/sessions/upload'), {'Accept':'application/json','X-API-Key':'***'});
      const t0 = performance.now();
      const res = await fetch(apiUrl('/sessions/upload'), {
        method: 'POST',
        headers: { 'X-API-Key': els.apiKey.value.trim() }, // IMPORTANT: no manual Content-Type
        body: fd
      });
      const text = await res.text();
      const dur = Math.round(performance.now()-t0);
      logHttpRes(id, 'POST '+apiUrl('/sessions/upload'), dur, res.status, Object.fromEntries(res.headers.entries()), text);

      if(res.status === 201 || res.ok){
        setStatus('uploaded');
        log('info','Upload complete (session created). Triggering enrichment…');
        // Best-effort parse to show id
        let sid=null; try{ const j=JSON.parse(text); sid = j.id || j.session_id || (j.data && j.data.id) || null; }catch{}
        // Enrichment trigger (best effort if documented)
        try{ await apiFetch('/sessions/enrich', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({session_id: sid})}); }catch{}
        resetUIAfterUpload();
        await loadSessionsList(); // refresh
      }else{
        throw new Error(text || res.statusText);
      }
    }catch(e){
      log('error','Upload failed: ' + e.message + "\n");
      alert('Upload failed:\n' + e.message);
    }
  };

  async function loadSessionsList(){
    els.sessionList.innerHTML = '';
    // If vendor selected, fetch their details (includes sessions)
    const vendId = els.vendorSel.value;
    if(vendId){
      try{
        const d = await apiFetch(`/vendors/${vendId}`);
        const sessions = (d && d.data && d.data.sessions) || [];
        renderSessions(sessions);
        return;
      }catch(e){ log('error', 'Could not load vendor sessions: ' + e.message); }
    }
    // Otherwise try a general sessions list if available.
    // If no endpoint exists, keep empty gracefully.
  }

  function renderSessions(sessions){
    els.sessionList.innerHTML = '';
    if(!Array.isArray(sessions) || sessions.length===0){
      const p = document.createElement('div'); p.className='muted'; p.textContent='No sessions found.'; els.sessionList.appendChild(p); return;
    }
    sessions.slice().sort((a,b)=> (b.start_time||'').localeCompare(a.start_time||'')).forEach(s=>{
      const d = document.createElement('div');
      d.className = 'card';
      d.innerHTML = `
        <div class="row" style="justify-content:space-between">
          <div><strong>${escapeHtml(s.session_type||'session')}</strong> <span class="muted">• ${escapeHtml(s.status||'')}</span></div>
          <span class="pill">${(s.processing_status||'').toLowerCase()}</span>
        </div>
        <div class="small muted">${escapeHtml(s.start_time||'')} → ${escapeHtml(s.end_time||'')}</div>
        ${s.user_notes ? `<div class="small" style="margin-top:6px;white-space:pre-wrap">${escapeHtml(s.user_notes)}</div>`:''}
        ${Array.isArray(s.files_uploaded)&&s.files_uploaded.length ? `<div class="thumbs" style="margin-top:6px">${s.files_uploaded.map(f => f.type==='image'?`<img src="${f.url}" alt="">`:`<span class="pill">${escapeHtml(f.filename)}</span>`).join('')}</div>`:''}
      `;
      els.sessionList.appendChild(d);
    });
  }

  function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // ------------------ Init ------------------
  loadCfg();
  // preload lists if config exists
  if(els.apiBase.value && els.apiKey.value){
    refreshLists().catch(e=>log('error','Could not load initial data: '+e.message));
  }

})();
</script>
</body>
</html>
