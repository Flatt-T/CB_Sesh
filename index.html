<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conference Buddy — Session Recorder</title>
  <style>
    :root {
      --bg: #0b1020; --fg: #e6efff; --muted:#8aa2c8; --accent:#5ea1ff; --accent-2:#12d3cf;
      --bad:#ff6b6b; --good:#3ddc84; --warn:#ffd166;
    }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Segoe UI Variable", "SF Pro Text", Arial, sans-serif; background: var(--bg); color: var(--fg); }
    a { color: var(--accent); }
    header { display:flex; align-items:center; justify-content:space-between; gap: 1rem; padding: 16px 20px; border-bottom: 1px solid #1f2b4a; position:sticky; top:0; backdrop-filter:saturate(1.2) blur(6px); background: color-mix(in srgb, var(--bg) 85%, transparent); z-index: 10; }
    header h1 { margin: 0; font-size: clamp(16px, 2.8vw, 20px); font-weight: 700; letter-spacing:.2px; }
    .status { font-size: 12px; padding: 3px 8px; border-radius: 999px; background: #17223d; color: var(--muted); }
    .status.ok { color:#032; background: #2bffb31e; border:1px solid #2bffb3; }
    .status.bad { color:#300; background:#ff6b6b1e; border:1px solid var(--bad); }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; padding: 16px 20px 100px; }
    .card { background: #0e1730; border: 1px solid #22335b; border-radius: 16px; box-shadow: 0 6px 24px #00000033; }
    .card h2 { margin: 0; padding: 14px 16px; font-size: 16px; border-bottom: 1px solid #22335b; color: #cfe3ff; }
    .card .body { padding: 14px 16px 16px; }
    label { display:block; font-size:12px; color: var(--muted); margin: 8px 0 6px; }
    input[type=text], textarea, select { width: 100%; border-radius: 10px; border: 1px solid #365085; background: #0b142b; color: var(--fg); padding: 10px 12px; outline: none; }
    textarea { min-height: 110px; resize: vertical; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .row > * { flex: 1; }
    .btn { appearance:none; border:1px solid #2c4376; background:#102045; color:#d9e6ff; padding:10px 14px; border-radius: 999px; cursor:pointer; font-weight:600; font-size: 14px; }
    .btn:hover { filter: brightness(1.13); }
    .btn:disabled { opacity:.55; cursor:not-allowed; }
    .btn.primary { background: linear-gradient(90deg, var(--accent), var(--accent-2)); border: none; color:#031327; }
    .btn.danger { background:#2d0f14; border-color:#64262c; color:#ffb3b7; }
    .pill { padding:6px 10px; border-radius:999px; background:#111c3a; border:1px solid #274274; font-size: 12px; color:var(--muted) }
    .thumbs { display:flex; gap:10px; flex-wrap: wrap; }
    .thumb { position:relative; }
    .thumb img { width: 96px; height: 96px; object-fit: cover; border-radius: 12px; border:1px solid #2b3f70; }
    .thumb button { position:absolute; top:-8px; right:-8px; border-radius:999px; width:24px; height:24px; font-size:14px; line-height: 0; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; background:#0a132a; border:1px solid #22335b; padding: 2px 6px; border-radius: 6px; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "SF Mono", monospace; font-size: 12px; white-space: pre-wrap; background: #050a18; color: #cfe3ff; border: 1px solid #253b6d; border-radius: 12px; padding: 12px; max-height: 260px; overflow: auto; }
    .footerbar { position: fixed; bottom: 0; left:0; right:0; background: color-mix(in srgb, var(--bg) 85%, transparent); backdrop-filter: blur(6px) saturate(1.2); border-top: 1px solid #22335b; padding: 10px 16px; display:flex; gap:10px; align-items:center; justify-content: space-between; }
    .tag { border:1px solid #2b3f70; padding: 6px 8px; border-radius: 6px; font-size: 12px; color: var(--muted);} 
    dialog { border: 1px solid #22335b; background: #0b142b; color: var(--fg); border-radius: 16px; max-width: 720px; width: min(720px, 96vw); }
    dialog::backdrop { background: #00071699; }
    .muted { color: var(--muted); }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <header>
    <h1>Conference Buddy — Recorder <span class="muted">mobile · dark/blue</span></h1>
    <div class="row" style="justify-content:flex-end; gap:8px;">
      <span id="connBadge" class="status bad">Disconnected</span>
      <button class="btn" id="openSettings">API Settings</button>
      <button class="btn" id="openLogs">API Logs & Self-Test</button>
    </div>
  </header>  <section class="grid">
    <article class="card">
      <h2>Session Recorder</h2>
      <div class="body">
        <div class="row">
          <div>
            <label>Conference</label>
            <div class="row">
              <input id="conferenceName" type="text" placeholder="Optional; blank ⇒ ‘Unknown Conference’." />
              <button class="btn" id="newConference">+ New</button>
            </div>
          </div>
          <div>
            <label>Vendor</label>
            <div class="row">
              <input id="vendorName" type="text" placeholder="Optional; blank ⇒ ‘Unknown Vendor’ (scoped to chosen conference)." />
              <button class="btn" id="newVendor">+ New</button>
            </div>
          </div>
        </div>
        <div class="row" style="margin-top: 10px; gap: 12px;">
          <button class="btn primary" id="btnStart">▶ Start (audio begins)</button>
          <button class="btn" id="btnStopUpload" disabled>■ Stop & Upload</button>
          <button class="btn" id="btnPrev">Previous Sessions</button>
        </div>
        <div class="row" style="margin-top:8px; gap: 12px;">
          <span class="tag">Audio: <span id="audioState">idle</span></span>
          <span class="tag">Images: <span id="imgCount">0</span></span>
          <span class="tag">Session ID: <span id="sessionId">—</span></span>
        </div>
        <label style="margin-top:14px;">Notes</label>
        <textarea id="notes" placeholder="Key points, names, action items…"></textarea>
        <label style="margin-top:14px;">Photos</label>
        <div class="row">
          <input id="photoInput" type="file" accept="image/*" capture="environment" multiple />
          <button id="clearPhotos" class="btn danger" disabled>Clear</button>
        </div>
        <div id="thumbs" class="thumbs" style="margin-top:10px;"></div>
      </div>
    </article><article class="card">
  <h2>Previous Sessions</h2>
  <div class="body">
    <div class="row">
      <select id="prevSelect"></select>
      <button class="btn" id="loadPrev">Load</button>
    </div>
    <div id="prevMeta" class="muted" style="margin-top:10px;"></div>
  </div>
</article>

<article class="card">
  <h2>Status & Diagnostics</h2>
  <div class="body">
    <div class="row" style="gap:8px;">
      <span class="pill" id="diagReady">Ready.</span>
      <span class="pill">Browser: <span id="ua"></span></span>
    </div>
    <div class="log" id="diagLog" style="margin-top:12px;"></div>
  </div>
</article>

  </section>  <footer class="footerbar">
    <div class="row" style="gap:8px; align-items:center;">
      <span class="muted">Tip:</span>
      <span>Use <span class="kbd">API Settings</span> to set your backend base URL and key. Default is pre-filled.</span>
    </div>
    <div>
      <button class="btn" id="runSelfTest">Run Self-Test</button>
    </div>
  </footer>  <!-- Settings Modal -->  <dialog id="settingsDlg">
    <form method="dialog" style="margin:0;">
      <h2 style="margin: 0; padding: 14px 16px; border-bottom:1px solid #22335b;">API Settings</h2>
      <div class="body">
        <label>Backend API Base URL</label>
        <input id="cfgBase" type="text" placeholder="https://your-api.example.com" /><div class="row">
      <div>
        <label>API Key</label>
        <input id="cfgKey" type="text" placeholder="Paste your API key (or leave blank if not required)" />
      </div>
      <div>
        <label>Auth Mode</label>
        <select id="cfgMode">
          <option value="x-api-key">Header: X-API-Key</option>
          <option value="bearer">Header: Authorization: Bearer</option>
          <option value="query">Query param (?apiKey=...)</option>
        </select>
      </div>
    </div>

    <label>Query parameter name (when using Query mode)</label>
    <input id="cfgQueryName" type="text" placeholder="apiKey" />

    <div class="row" style="margin-top: 12px;">
      <button class="btn" value="cancel">Close</button>
      <button class="btn primary" id="saveCfg" value="default">Save</button>
    </div>
  </div>
</form>

  </dialog>  <!-- Logs Modal -->  <dialog id="logsDlg">
    <form method="dialog" style="margin:0;">
      <h2 style="margin: 0; padding: 14px 16px; border-bottom:1px solid #22335b;">Diagnostics & Logs</h2>
      <div class="body">
        <div class="row" style="align-items:center;">
          <div class="row" style="gap:8px;">
            <button class="btn" id="copyTxt" type="button">Copy .txt</button>
            <button class="btn" id="copyJson" type="button">Copy .json</button>
            <label><input id="verboseToggle" type="checkbox" /> Verbose</label>
          </div>
          <div class="row" style="justify-content:flex-end; gap:8px;">
            <button class="btn" id="clearLogs" type="button">Clear</button>
            <button class="btn" value="cancel">Close</button>
          </div>
        </div>
        <div id="logsView" class="log" style="margin-top: 12px;"></div>
      </div>
    </form>
  </dialog>  <script>
    /**
     * Conference Buddy — Session Recorder (single-file build)
     * Robust, heavily commented, with structured logging and self-test.
     *
     * This drop-in file fixes common GH Pages issues (script ordering, module loading),
     * enhances MediaRecorder reliability (Safari/WebKit fallbacks), stabilizes the API
     * client, and adds detailed diagnostics to quickly pinpoint problems.
     *
     * Back-end API (as documented): https://conference-buddy-geoutils.replit.app
     * Key endpoints used (unauthenticated endpoints may return 401 if key required):
     *   GET  /health
     *   POST /conferences, GET /conferences
     *   POST /vendors, GET /vendors
     *   POST /sessions/upload (multipart), GET /sessions/{id}
     *   GET  /reports/session/{id}
     *
     * Everything below is pure vanilla JS; no bundler required.
     */

    // ---------------------------
    // Config & State
    // ---------------------------
    const CONFIG_DEFAULTS = {
      baseUrl: 'https://conference-buddy-geoutils.replit.app',
      apiKey: '',
      authMode: 'x-api-key', // 'x-api-key' | 'bearer' | 'query'
      queryName: 'apiKey',
      timeoutMs: 25000,
      verbose: false
    };

    const State = {
      mediaRecorder: null,
      recChunks: [],
      recMime: null,
      recStart: null,
      images: [], // File[]
      lastSessionId: null,
      logs: [],
      verbose: false,
      settings: loadSettings()
    };

    // Persistent settings in localStorage for stability across refreshes.
    function loadSettings() {
      try {
        const s = JSON.parse(localStorage.getItem('cbSettings') || 'null');
        return { ...CONFIG_DEFAULTS, ...(s || {}) };
      } catch { return { ...CONFIG_DEFAULTS }; }
    }
    function saveSettings() {
      localStorage.setItem('cbSettings', JSON.stringify(State.settings));
    }

    // ---------------------------
    // Utility: Logging
    // ---------------------------
    function log(level, msg, extra) {
      const entry = { t: new Date().toISOString(), level, msg, ...(extra ? { extra } : {}) };
      State.logs.push(entry);
      // append to on-page logs
      const line = `[${entry.t}] ${level.toUpperCase()} — ${msg}` + (extra ? `\n${safeStringify(extra)}` : '');
      const el1 = document.getElementById('diagLog');
      if (el1) { el1.textContent = (el1.textContent + (el1.textContent ? '\n' : '') + line).slice(-15000); }
      const el2 = document.getElementById('logsView');
      if (el2 && !document.getElementById('logsDlg').open) { el2.textContent = (el2.textContent + (el2.textContent ? '\n' : '') + line).slice(-40000); }
    }
    const info = (m, e) => log('info', m, e);
    const warn = (m, e) => log('warn', m, e);
    const error = (m, e) => log('error', m, e);
    function safeStringify(obj) { try { return JSON.stringify(obj, null, 2); } catch { return String(obj); } }

    // ---------------------------
    // Utility: API Client
    // ---------------------------
    async function apiFetch(path, { method = 'GET', headers = {}, query = {}, body, formData, timeoutMs } = {}) {
      const { baseUrl, apiKey, authMode, queryName } = State.settings;
      const url = new URL(path.replace(/^\//, ''), baseUrl.endsWith('/') ? baseUrl : baseUrl + '/');
      // add query params
      for (const [k, v] of Object.entries(query || {})) url.searchParams.set(k, v);
      if (authMode === 'query' && apiKey) url.searchParams.set(queryName || 'apiKey', apiKey);

      const h = new Headers(headers);
      if (authMode === 'x-api-key' && apiKey) h.set('X-API-Key', apiKey);
      if (authMode === 'bearer' && apiKey) h.set('Authorization', `Bearer ${apiKey}`);
      if (!formData && body && !(body instanceof Blob)) h.set('Content-Type', 'application/json');

      const init = {
        method,
        headers: h,
        mode: 'cors',
        credentials: 'omit',
        cache: 'no-store'
      };
      if (formData) init.body = formData; else if (body) init.body = body instanceof Blob ? body : JSON.stringify(body);

      const tmo = timeoutMs ?? State.settings.timeoutMs;
      info(`API → ${method} ${url.pathname}${url.search}`);
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort('timeout'), tmo);
      try {
        const res = await fetch(url, { ...init, signal: controller.signal });
        const txt = await res.text(); // read once for richer error messages
        let data = null;
        try { data = txt ? JSON.parse(txt) : null; } catch {}
        const payload = data ?? txt;
        if (!res.ok) throw { status: res.status, statusText: res.statusText, payload };
        info(`API ← ${res.status} ${method} ${url.pathname}`, { sample: typeof payload === 'string' ? payload.slice(0, 200) : payload });
        return payload;
      } catch (e) {
        error(`API ✖ ${method} ${url.pathname}`, e);
        throw e;
      } finally { clearTimeout(t); }
    }

    async function pingHealth() {
      try {
        const res = await apiFetch('/health', {});
        return !!res || true; // any 200 OK counts
      } catch { return false; }
    }

    // ---------------------------
    // Media: audio recording
    // ---------------------------
    function pickBestAudioMime() {
      const prefs = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4', // Safari 17+
        'audio/ogg;codecs=opus',
        'audio/ogg',
        'audio/wav' // last resort
      ];
      for (const m of prefs) {
        if (MediaRecorder.isTypeSupported?.(m)) return m;
      }
      return ''; // let browser decide
    }

    async function startRecording() {
      const btnStart = document.getElementById('btnStart');
      btnStart.disabled = true;
      State.recChunks = [];
      const mime = pickBestAudioMime();
      State.recMime = mime || undefined;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mr = new MediaRecorder(stream, mime ? { mimeType: mime } : {});
        State.mediaRecorder = mr;
        State.recStart = Date.now();
        mr.ondataavailable = (ev) => { if (ev.data && ev.data.size) State.recChunks.push(ev.data); };
        mr.onerror = (ev) => { error('MediaRecorder error', ev.error || ev); };
        mr.onstart = () => { setAudioState('recording'); info('Recording started', { mime: mr.mimeType, timeslice: null }); };
        mr.onstop = () => { setAudioState('stopped'); info('Recording stopped'); };
        mr.start(); // no timeslice → single blob
        document.getElementById('btnStopUpload').disabled = false;
      } catch (e) {
        btnStart.disabled = false;
        setAudioState('error');
        error('Could not start recording (permission or device issue)', e);
        alert('Microphone permission denied or not available. Please allow mic access and try again.');
      }
    }

    function setAudioState(s) {
      document.getElementById('audioState').textContent = s;
    }

    function collectBlob() {
      if (!State.recChunks?.length) return null;
      const type = State.recMime || (State.recChunks[0]?.type || 'audio/webm');
      return new Blob(State.recChunks, { type });
    }

    async function stopAndUpload() {
      const btn = document.getElementById('btnStopUpload');
      btn.disabled = true;
      try {
        await new Promise((resolve) => {
          if (!State.mediaRecorder) return resolve();
          if (State.mediaRecorder.state !== 'inactive') {
            State.mediaRecorder.addEventListener('stop', resolve, { once: true });
            State.mediaRecorder.stop();
          } else resolve();
        });
      } catch {}

      const audioBlob = collectBlob();
      if (!audioBlob) {
        warn('No audio captured; proceeding to upload notes/images only.');
      }

      const conference = (document.getElementById('conferenceName').value || 'Unknown Conference').trim();
      const vendor     = (document.getElementById('vendorName').value || 'Unknown Vendor').trim();
      const notes      = document.getElementById('notes').value.trim();
      const durationMs = State.recStart ? (Date.now() - State.recStart) : 0;

      const fd = new FormData();
      if (audioBlob) fd.append('audio', audioBlob, `session-${Date.now()}.webm`);
      for (const [i, f] of State.images.entries()) fd.append('images', f, f.name || `image-${i}.jpg`);
      fd.append('conferenceName', conference);
      fd.append('vendorName', vendor);
      fd.append('notes', notes);
      fd.append('clientUserAgent', navigator.userAgent);
      fd.append('startTime', State.recStart ? new Date(State.recStart).toISOString() : '');
      fd.append('endTime', new Date().toISOString());
      fd.append('durationMs', String(durationMs));

      let payload;
      try {
        payload = await apiFetch('/sessions/upload', { method: 'POST', formData: fd });
      } catch (e) {
        // Fallback: send JSON if multipart not accepted (as per admin KB recommendation)
        warn('Multipart upload failed — falling back to JSON payload.');
        const base64Audio = audioBlob ? await blobToBase64(audioBlob) : null;
        payload = await apiFetch('/sessions/upload', {
          method: 'POST',
          body: {
            conferenceName: conference,
            vendorName: vendor,
            notes,
            durationMs,
            startTime: State.recStart ? new Date(State.recStart).toISOString() : null,
            endTime: new Date().toISOString(),
            audioBase64: base64Audio,
            images: await Promise.all(State.images.map(f => fileToDict(f)))
          }
        });
      }

      // Interpret response generically: expect { id } or { sessionId } or { data: { id } }
      const id = payload?.id || payload?.sessionId || payload?.data?.id || null;
      State.lastSessionId = id;
      document.getElementById('sessionId').textContent = id || '—';
      addPrevSession({ id, conference, vendor, at: new Date().toISOString(), durationMs });

      info('Upload complete', { id, payload });
      if (id) alert(`Uploaded! Session ID: ${id}`);
      resetRecorder();
    }

    function resetRecorder() {
      State.mediaRecorder = null; State.recChunks = []; State.recStart = null; setAudioState('idle');
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStopUpload').disabled = true;
    }

    // Helpers for JSON fallback
    async function blobToBase64(blob) { const b = await blob.arrayBuffer(); return btoa(String.fromCharCode(...new Uint8Array(b))); }
    async function fileToDict(file) { const base64 = await blobToBase64(file); return { name: file.name, type: file.type, base64 }; }

    // ---------------------------
    // Images UI
    // ---------------------------
    function renderThumbs() {
      const c = document.getElementById('thumbs'); c.textContent = '';
      State.images.forEach((file, idx) => {
        const url = URL.createObjectURL(file);
        const wrap = document.createElement('div'); wrap.className = 'thumb';
        const img = document.createElement('img'); img.src = url; img.alt = file.name || `image-${idx}`;
        const del = document.createElement('button'); del.className = 'btn danger'; del.textContent = '×';
        del.addEventListener('click', () => { URL.revokeObjectURL(url); State.images.splice(idx, 1); renderThumbs(); syncImgCount(); });
        wrap.appendChild(img); wrap.appendChild(del); c.appendChild(wrap);
      });
    }
    function syncImgCount() { document.getElementById('imgCount').textContent = String(State.images.length); document.getElementById('clearPhotos').disabled = State.images.length === 0; }

    // ---------------------------
    // Previous sessions (local cache for quick recall if API doesn’t expose listing)
    // ---------------------------
    function loadPrevFromStorage() {
      try { return JSON.parse(localStorage.getItem('cbPrev') || '[]'); } catch { return []; }
    }
    function savePrevToStorage(list) { localStorage.setItem('cbPrev', JSON.stringify(list.slice(-50))); }
    function addPrevSession(entry) {
      const list = loadPrevFromStorage();
      list.push(entry);
      savePrevToStorage(list);
      fillPrevSelect(list);
    }
    function fillPrevSelect(list = loadPrevFromStorage()) {
      const sel = document.getElementById('prevSelect');
      sel.textContent = '';
      if (!list.length) { const o = document.createElement('option'); o.value = ''; o.textContent = 'No local history yet'; sel.appendChild(o); return; }
      list.slice().reverse().forEach((it) => {
        const o = document.createElement('option');
        o.value = it.id || '';
        o.textContent = `${it.at?.slice(0, 19).replace('T',' ')} — ${it.conference} / ${it.vendor}${it.id ? ' — ' + it.id : ''}`;
        sel.appendChild(o);
      });
    }

    async function loadPrevSession() {
      const id = document.getElementById('prevSelect').value;
      const metaEl = document.getElementById('prevMeta');
      metaEl.textContent = '';
      if (!id) { metaEl.textContent = 'No ID selected.'; return; }
      try {
        const data = await apiFetch(`/sessions/${encodeURIComponent(id)}`);
        metaEl.textContent = safeStringify(data);
      } catch (e) {
        metaEl.textContent = 'Failed to fetch from API; showing cached info only.';
      }
    }

    // ---------------------------
    // New Conference / Vendor helpers (best-effort; names may vary by API)
    // ---------------------------
    async function createConference(name) {
      return apiFetch('/conferences', { method: 'POST', body: { name } });
    }
    async function createVendor(name, conferenceIdOrName) {
      return apiFetch('/vendors', { method: 'POST', body: { name, conference: conferenceIdOrName } });
    }

    // ---------------------------
    // Self test
    // ---------------------------
    async function runSelfTest() {
      const base = State.settings.baseUrl;
      info('Self-test started');
      const results = [];
      try {
        results.push(['HEALTH', await pingHealth() ? 'ok' : 'fail']);
        try { await apiFetch('/conferences', {}); results.push(['GET /conferences', 'ok']); } catch (e) { results.push(['GET /conferences', 'fail']); }
        try { await apiFetch('/vendors', {}); results.push(['GET /vendors', 'ok']); } catch (e) { results.push(['GET /vendors', 'fail']); }
        const msg = 'Self-test: ' + results.map(([n,s]) => `${n}=${s}`).join(', ');
        info(msg);
        alert(`Self-test against ${base}:\n` + results.map(([n,s]) => `• ${n} → ${s}`).join('\n'));
      } catch (e) {
        error('Self-test error', e);
      }
    }

    // ---------------------------
    // Settings dialog handlers
    // ---------------------------
    function openSettingsDlg() {
      const { baseUrl, apiKey, authMode, queryName } = State.settings;
      document.getElementById('cfgBase').value = baseUrl;
      document.getElementById('cfgKey').value = apiKey;
      document.getElementById('cfgMode').value = authMode;
      document.getElementById('cfgQueryName').value = queryName;
      document.getElementById('settingsDlg').showModal();
    }

    function saveSettingsFromDlg(ev) {
      ev?.preventDefault?.();
      State.settings.baseUrl = document.getElementById('cfgBase').value.trim() || CONFIG_DEFAULTS.baseUrl;
      State.settings.apiKey = document.getElementById('cfgKey').value.trim();
      State.settings.authMode = document.getElementById('cfgMode').value;
      State.settings.queryName = document.getElementById('cfgQueryName').value.trim() || 'apiKey';
      saveSettings();
      info('Settings saved', { ...State.settings, apiKey: State.settings.apiKey ? '***' : '' });
      document.getElementById('settingsDlg').close();
      refreshConnectionBadge();
    }

    async function refreshConnectionBadge() {
      const ok = await pingHealth();
      const b = document.getElementById('connBadge');
      b.textContent = ok ? 'Connected' : 'Disconnected';
      b.classList.toggle('ok', !!ok); b.classList.toggle('bad', !ok);
    }

    // ---------------------------
    // Wire up DOM after content is ready
    // ---------------------------
    document.addEventListener('DOMContentLoaded', async () => {
      document.getElementById('ua').textContent = navigator.userAgent;

      // Buttons
      document.getElementById('btnStart').addEventListener('click', startRecording);
      document.getElementById('btnStopUpload').addEventListener('click', stopAndUpload);
      document.getElementById('btnPrev').addEventListener('click', () => document.getElementById('logsDlg').showModal());

      document.getElementById('photoInput').addEventListener('change', (e) => {
        State.images = Array.from(e.target.files || []);
        renderThumbs(); syncImgCount();
      });
      document.getElementById('clearPhotos').addEventListener('click', () => { State.images = []; renderThumbs(); syncImgCount(); });

      document.getElementById('openSettings').addEventListener('click', openSettingsDlg);
      document.getElementById('saveCfg').addEventListener('click', saveSettingsFromDlg);

      document.getElementById('openLogs').addEventListener('click', () => { document.getElementById('logsView').textContent = State.logs.map(e => `[${e.t}] ${e.level.toUpperCase()} — ${e.msg}`).join('\n'); document.getElementById('logsDlg').showModal(); });
      document.getElementById('copyTxt').addEventListener('click', async () => { await navigator.clipboard.writeText(State.logs.map(e => `[${e.t}] ${e.level.toUpperCase()} — ${e.msg}` + (e.extra ? `\n${safeStringify(e.extra)}` : '')).join('\n')); alert('Logs copied (.txt)'); });
      document.getElementById('copyJson').addEventListener('click', async () => { await navigator.clipboard.writeText(JSON.stringify(State.logs, null, 2)); alert('Logs copied (.json)'); });
      document.getElementById('clearLogs').addEventListener('click', () => { State.logs = []; document.getElementById('logsView').textContent = ''; document.getElementById('diagLog').textContent = ''; });
      document.getElementById('verboseToggle').addEventListener('change', (e) => { State.verbose = !!e.target.checked; info(`Verbose ${State.verbose ? 'on' : 'off'}`); });

      document.getElementById('loadPrev').addEventListener('click', loadPrevSession);
      document.getElementById('newConference').addEventListener('click', async () => {
        const name = (document.getElementById('conferenceName').value || '').trim() || prompt('Conference name?');
        if (!name) return;
        try { const res = await createConference(name); info('Conference created', res); alert('Conference created.'); } catch (e) { error('Create conference failed', e); alert('Failed to create conference — see logs.'); }
      });
      document.getElementById('newVendor').addEventListener('click', async () => {
        const v = (document.getElementById('vendorName').value || '').trim() || prompt('Vendor name?');
        const c = (document.getElementById('conferenceName').value || '').trim() || prompt('Link to conference (ID or name)?');
        if (!v || !c) return;
        try { const res = await createVendor(v, c); info('Vendor created', res); alert('Vendor created.'); } catch (e) { error('Create vendor failed', e); alert('Failed to create vendor — see logs.'); }
      });

      fillPrevSelect();
      refreshConnectionBadge();
      info('App initialized');
    }, { once: true });
  </script></body>
</html>
